# [最长回文子串](https://github.com/Bulandent/js-leetcode-2021/issues/9)

## 最长回文子串

难度：中等
来源：[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

示例 1：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```
输入：s = "cbbd"
输出："bb"
```

示例 3：

```
输入：s = "a"
输出："a"
```

示例 4：

```
输入：s = "ac"
输出："a"
```

提示：

```
1 <= s.length <= 1000
s 仅由数字和英文字母（大写和/或小写）组成
```

**思路：**


**题解一：暴力破解**

```js
var longestPalindrome = function(s) {
    if (s.length < 2) return s 

    let max = 1, index = 0, len = s.length
    for (let i = 0, l = len - 1; i < l; i++) {
        for (let j = i + 1; j < len; j++) {
            if (j - i + 1 > max && isPalindrome(s, i, j)) {
                max = j - i + 1
                index = i
            }
        }
    }    
    return s.substring(index, max + index)
};

function isPalindrome(str, begin, end) {
    while (begin < end) {
        if (str[begin] !== str[end]) {
            return false
        }
        begin++
        end--
    }
    return true
}
```

**题解二：双指针**

```js
var longestPalindrome = function(s) {
    if (s == '') return ''
    
    const len = s.length
    let index = 0, maxL = 0, begin = 0
    while (index < len) {
        let right = index, left = index;
        while (index < len && s[index + 1] == s[index]) {
            index++
            right++
        }
        while (right < len && left >= 0 && s[right] == s[left]) {
            right++
            left--
        }
        right-- 
        left++
        if (right - left + 1 > maxL) {
            maxL = right - left + 1
            begin = left
        }
        index++
    }
    return s.substr(begin, maxL)
}
```